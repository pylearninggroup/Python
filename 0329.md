# 密码学基础工具箱
说道密码学，大家可能以为这玩意真的很高深，其实也确实是这样的；但是如果想要对密码学的一些技术有一些入门的了解，还是很简单的。这里我们就简单的介绍下密码学的一些 "工具箱"，要不，下一篇都会看不懂的。

注意：为了防止概念混淆，我们统一把密码（也就是你登录某个账号时输入的那个东西）说成 "口令"。

## 加密、解密与密钥是什么？
加密就是把明文变成密文的过程，解密就是把密文变成明文的过程。此二者是互逆的，就好似减法是加法的逆运算一样。在加密和解密的过程中，需要一个 "密钥" 来参与数学运算，这个密钥就好像是你的钥匙一样。

## 对称密码
所谓对称密码（对称加密），就是加密和解密的时候使用同一个密钥。这个很好理解，就像你用 WinRAR 啥玩意压缩一个文件的时候设置了一个口令，解压缩的时候也要用这个密码才能成功提取文件一样，这个 "口令" 就相当于我们上面说的密钥。对称密码有两种不同的色剂，可以分为流密码、分组密码。

分组密码共有五种分组模式，在这里就不提了否则又要严重跑题并且增加文章长度，感兴趣的可以去围观维基百科。

我们常用的对称密码有 DES、3DES、AES、Blowfish、IDEA、RC5、RC6 等。其中 AES 竞标时最后入围共有五种算法：Rijndael、Serpent、 Twofish、MARS 和 RC6，最后 Rijndael 被选作 AES。

## 非对称密码
非对称密码（非对称加密）也被称作公钥密码，所谓 "非对称"，意思就是加密和解密的时候使用不同的密钥，挺难理解的是吧，但是咱得说，这种非对称的想法可是密码学上最大的突破之一。

咱在这里只要知道，非对称密码有一组密钥，这组密钥中，公开的被称为公钥，私有的被称作私钥；使用公钥加密的文件只有使用对应的私钥才能解开；使用私钥加密（签名）的文件只有使用对应的公钥才能解开。理论上来说，每一对公钥和私钥之间有着严谨的数学关系，很难互相推导。但是吧，在目前的大部分实现中 (RSA)，通过公钥推导出对应的私钥很难，但是通过私钥推公钥是很可能的。，感谢 jaehee~임재희的指正，openssl rsa -in privkey.pem -pubout

非对称密码中比较出名的有 RSA 和椭圆曲线（ECC）。

总结：对称密码和非对称密码的优缺点咱能看出来，对称密码的实现比较简单，但是能干的事情却没有公钥密码那么多；但是公钥密码的设计通常要涉及到一些比较复杂的数学问题，所以公钥密码的速度通常要比对称密码差几个数量级；并且，公钥密码需要比较长的密钥长度才能够保证类似等同于对称密码的加密强度，NIST 的建议是，RSA 和 DSA 是 1024 位，ECC 是 160 位，相应的对称分组密码（比如说 AES-CBC）的密钥长度是 80 位；或者说 AES 为 128 位、RSA 2048 和 ECC 256 位。

## 单向散列函数

单向散列函数就相当于消息的指纹，指纹这东西嘛，就是接近独一无二的咯。咱把一个消息（文件）使用单向散列函数处理一下，就会有一个定长的 "指纹"（也被称作散列值、摘要），我们就可以用这段摘要来唯一的代表这个消息；假如某天这个消息变化了哪怕是 1 比特，那么这个摘要也会变得面目全非，这样咱就能知道原来的消息被篡改了。

换句话说，单向散列函数可以用来验证消息的完整性。

咱常用的单向散列函数有 MD5、SHA1 等等。

## 消息认证码
消息认证码就是一种能够确定消息的完整性并且能够进行认证的技术。所谓 "完整性"、"一致性"，就是消息没有被篡改；所谓 "认证"，就是消息来自正确的发送者。消息认证码是一种结合了单向散列函数和对称密码的密码学技术。我们常用的 HMAC 就是其中之一。

## 数字签名
前面我们提到了公钥和私钥。我们知道公钥是公开的、私钥是私有的，如果我们使用私钥对某个文件进行加密（实际上应该被称作签名），那么任何人都可以对此进行解密，看似这里似乎失去了加密的意义，但这实际上可以证明一点：只有持有私钥的人才能够进行加密，这也意味着我们可以认证、防止否认、完整性。

咱一般都是对消息的散列进行 "签名"，因为公钥密码比较慢嘛。

## 伪随机数
如果读者学习过某些程序设计语言，可能记得他们的标准库中都有个类似 random 的东西可以生成某个范围内的随机数。我们看那个随机数似乎是统计学上随机的，但实际上咱要认识到一件非常残酷的事实：计算机是无法生成真正的随机数的，所以我们称随机数算法为 "伪随机数算法"。

这好像挺难理解的，咱只要知道吧，只要随机数算法是固定的，在给一个固定的 "种子"，那么每次生成的随机数也就是固定的、有规律可循的。

那这随机数有啥用啊？还记得上面提到的密钥吗，在密码学中，随机数可是无处不在的。

随机数有一些比较重要的性质：随机性（不存在统计学偏差）、不可预测性（不能根据过去的随机数序列预测未来的随机数序列）、不可重现性（不能重现该序列），密码学上使用的伪随机数算法至少也要做到前两点。

咱要记得，凡是线性随余算法的随机数都不能作为密码学应用；请使用语言的标准库中提供的密码学算法，或者是使用 OpenSSL、/dev/random这类安全的实现。

说了这么多密码学的工具，估计可能已经蒙圈了吧？别急，咱继续，接下来咱来分析下 SSH 设计的需求，这才是重头戏。



# 非对称加密：加密邮件
Windows用户需要安装gpg4win，Mac安装gpgtools，以windows为例
参考 https://dmesg.app/encrypted-email.html

# 对称加密：Veracrypt
参考这里
https://dmesg.app/encryption-gpg-veracrypt.html

# 使用Python实现密码学操作
用cryptography这个第三方扩展，举例
```python
from cryptography.fernet import Fernet

# Put this somewhere safe!
key = Fernet.generate_key()
print("key", key
      )
f = Fernet(key)
token = f.encrypt(b"A really secret message. Not for prying eyes.")
print(token)

p = f.decrypt(token)
print(p.decode('u8'))

# aes-256-cfb gcm

```

